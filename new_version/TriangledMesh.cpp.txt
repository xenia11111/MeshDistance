#include "TriangledMesh.hpp"
#include <set>
#include <time.h> 


    TriangledMesh::TriangledMesh(std::string const& filename)
    {
        Assimp::Importer importer;
        aiScene const* scene = importer.ReadFile(filename, aiProcess_Triangulate
            | aiProcess_JoinIdenticalVertices
            | aiProcess_OptimizeMeshes
            | aiProcess_DropNormals
            | aiProcess_GenBoundingBoxes);

        //std::cerr << scene->mRootNode->mNumChildren << "\n";
        processNode(scene->mRootNode, scene);
        if (!scene)
            throw std::runtime_error("No such file or directory");
        if (scene->mNumMeshes != 1)
            throw std::runtime_error("One mesh is required");
        aiMesh* aiMesh_ = scene->mMeshes[0];
        aabb_ = aiMesh_->mAABB;
        if (aiMesh_->mPrimitiveTypes != aiPrimitiveType_TRIANGLE)
            throw std::runtime_error("Triangled mesh required");

    }

    void TriangledMesh::processNode(aiNode* node, const aiScene* scene)
    {
        // process all the node's meshes (if any)
      
        for (unsigned int i = 0; i < node->mNumMeshes; i++)
        {
            aiMesh* mesh = scene->mMeshes[node->mMeshes[i]];
            processMesh(mesh, scene);
        }
        // then do the same for each of its children
        for (unsigned int i = 0; i < node->mNumChildren; i++)
        {
            processNode(node->mChildren[i], scene);
        }
    }


    void TriangledMesh::processMesh(aiMesh* mesh, const aiScene* scene)
    {
       
        for (uint32_t i = 0; i < mesh->mNumVertices; i++)
        {
            vertices_.push_back(mesh->mVertices[i]);
        }

        for (uint32_t i = 0; i < mesh->mNumFaces; ++i)
        {
            const aiFace face = mesh->mFaces[i];

           /* for (unsigned int k = 0; k < face->mNumIndices; k++) {
                auto index = face->mIndices[k];
                indices_.push_back(index);
                if (vertexToFace_.find(index) == vertexToFace_.end()) {
                    Triangle triangle
                    {
                        vertices_[face->mIndices[0]],
                        vertices_[face->mIndices[1]],
                        vertices_[face->mIndices[2]]
                    };
                    vertexToFace_.insert(std::make_pair(index, triangle));
                }
                else
                {
                    throw std::runtime_error("Two triangles for one point");
                }
            }*/
            faces_.push_back(mesh->mFaces[i]);
            Triangle triangle
            {
                vertices_[face.mIndices[0]],
                vertices_[face.mIndices[1]],
                vertices_[face.mIndices[2]],
            };
            averageAABBSize += getAABBSizeForTriangle(triangle);
        }
        averageAABBSize /= faces_.size();
    }

    std::vector<Triangle> TriangledMesh::getTriangles() const
    {
        std::vector<Triangle> triangles;
        for (auto const& face : faces_)
        {
            Triangle triangle
            {
                vertices_[face.mIndices[0]],
                vertices_[face.mIndices[1]],
                vertices_[face.mIndices[2]],
            };

            triangles.push_back(triangle);
            
        }
       
        return triangles;
    }

  float TriangledMesh::getDistanceTriangleToTriangle(TriangledMesh const& other)
    {
      auto fromCenter = this->aabb_.mMin + (this->aabb_.mMax - this->aabb_.mMin) / 2.0f;
      auto toCenter = other.aabb_.mMin + (other.aabb_.mMax - other.aabb_.mMin) / 2.0f;
      auto direction = (toCenter - fromCenter).Normalize();
      float distance = std::numeric_limits<float>::max();
       
        for (auto const& triangle : getTriangles())
        {
           
            for (auto const& otherTriangle: other.getTriangles())
            {
                operationsTriToTri++;
                if (operationsTriToTri == 7586)
                {
                    size_t b = 0;
                }
                distance = std::min(distance, geometry::getTriangleToTriangleDist(triangle, otherTriangle, direction));
                if (distance != std::numeric_limits<float>::max())
                {
                    size_t a = 0;
                }
               
            }
            
          
        }
        return distance;
    }


    

   float TriangledMesh::getDistance(TriangledMesh const& other)
    {
       
       auto fromCenter = other.aabb_.mMin + (other.aabb_.mMax - other.aabb_.mMin) / 2.0f;
       auto toCenter = this->aabb_.mMin + (this->aabb_.mMax - this->aabb_.mMin) / 2.0f;
       auto direction = (toCenter - fromCenter).Normalize();
        float distance = std::numeric_limits<float>::max();
        for (auto const& triangle : getTriangles())
        {
            
            for (auto const& vertex : other.vertices_)
            {
                operations++;
                distance = std::min(distance, geometry::getDistance(vertex, triangle, direction));
            }
        }
        return distance;
    }


